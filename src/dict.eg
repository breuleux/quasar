
require:
   .util ->
      tuck, fork-identify
      ID
      methods, fields
   "./proxy" ->
      setup-proxy, deprox, proxy
   .clobber ->
      object-clobber-helper
   kaiser


provide:
   Dict

_items = items

class Dict:

   constructor{data = {=}} =
      @data = object with items{data}

   get{key} =
      @data[key]

   has{key} =
      Object.has-own-property.call{@data, key}

   set{String? key or Number? key, value} =
      @data[key] = value

   .delete{key} =
      delete @data[key]

   items{} =
      _items{@data}

   [^Symbol.equals]{other} =
      Dict? other and @data == other.data

   ;; [^methods.proxy]{tracks, patch} =
   ;;    DictProxy{@, tracks, patch}

   ;; [^methods.iterate-properties]{} =
   ;;    Object.prototype[methods.iterate-properties].call{@data, @}

   [^methods.fork]{} =
      rval = Dict{}
      items{@data} each {key, value} ->
         rval.data[key] = value
      rval

   ;; [^methods.patch]{patch, dir} =
   ;;    Object.prototype[methods.patch].call{@data, patch, dir, @}

   [^methods.clobber]{new-dict, dir} =
      if not Dict? new-dict:
         return dir.replace{@, new-dict, false}
      dir.unlist{@}
      object-clobber-helper{
         @data, new-dict.data, items
         {a, b} -> Object.has-own-property.call{a, b}
      } each
         #delete{k} ->
            dir.exit{@data[k]}
            delete @data[k]
         #put{k, v} ->
            @data[k] = dir.clobber{@data[k], v}
      tuck{@, ID, new-dict[ID]}
      dir.list{@}
      @

   gen [^methods.relevant-changes]{reads, writes} =
      items{writes or {=}} each
         {name, _} and r is reads[name] when r.not-empty{} ->
            yield r
         r is reads["@iter"] when r??.not-empty{} ->
            yield r



class DictProxy:

   constructor{obj, tracks, patch} =
      setup-proxy{@, obj, tracks, patch}

   get{key} =
      @[methods.register-tracks]{key, true}
      proxy{@[fields.obj].get{key}
            @[fields.tracks]
            @[fields.patch]}

   has{key} =
      @[methods.register-tracks]{key, true}
      @[fields.obj].has{key}

   set{key, value} =
      o = @[fields.obj]
      @[methods.register-patch]{key, #update{deprox{value}}}

   .delete{key} =
      @[methods.register-patch]{key, #delete{}}

   items{} =
      @[methods.register-tracks]{"@iter", true}
      @[fields.obj].items{} each {k, v} ->
         {k, proxy{v, @[fields.tracks], @[fields.patch]}}



kaiser.register{Dict} with {
   package = require: ..package
   name-variant = .Dict
   serialize{@} =
      @data
   deserialize{obj} =
      Dict{obj}
   create{} =
      Dict{}
   fill{@, values} =
      @data = values
   proxy{@, tracks, patch} =
      DictProxy{@, tracks, patch}
}

