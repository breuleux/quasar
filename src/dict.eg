
require:
   .util ->
      tuck, fork-identify
      ID
      methods, fields
   "./proxy" ->
      setup-proxy, deprox, proxy
   .clobber ->
      object-clobber-helper
   kaiser


provide:
   Dict, DictProxy, DictTrack

_items = items

class Dict:

   constructor{data = {=}} =
      @data = object with items{data}

   get{key} =
      @data[key]

   has{key} =
      Object.has-own-property.call{@data, key}

   set{String? key or Number? key, value} =
      @data[key] = value

   .delete{key} =
      delete @data[key]

   items{} =
      _items{@data}

   [^Symbol.equals]{other} =
      Dict? other and @data == other.data


class DictTrack:
   constructor{init} =
      init and [[@] &: init]
   gen [^methods.relevant-changes]{writes} =
      items{writes or {=}} each
         {name, _} and r is @[name] when r.not-empty{} ->
            yield r
         r is @["@iter"] when r??.not-empty{} ->
            yield r


class DictProxy:

   constructor{obj, tracks, patch} =
      setup-proxy{@, obj, tracks, patch, DictTrack}

   get{key} =
      @[methods.register-tracks]{key, true}
      proxy{@[fields.obj].get{key}
            @[fields.tracks]
            @[fields.patch]}

   has{key} =
      @[methods.register-tracks]{key, true}
      @[fields.obj].has{key}

   set{key, value} =
      o = @[fields.obj]
      @[methods.register-patch]{key, #update{deprox{value}}}

   .delete{key} =
      @[methods.register-patch]{key, #delete{}}

   items{} =
      @[methods.register-tracks]{"@iter", true}
      @[fields.obj].items{} each {k, v} ->
         {k, proxy{v, @[fields.tracks], @[fields.patch]}}



kaiser.register{Dict} with {
   package = require: ..package
   name-variant = .Dict
   serialize{@} =
      @data
   deserialize{obj} =
      Dict{obj}
   create{} =
      Dict{}
   fill{@, values} =
      @data = values
   proxy{@, tracks, patch} =
      DictProxy{@, tracks, patch}
}

