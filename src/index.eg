
require:
   .object-fill -> object-clobber-helper
   .array-fill -> array-clobber-helper
   .misc-fill
   .util ->
      tuck, identify, fork-identify, next-id
      ID, FORKID, VERSION, DIRECTORY
      methods, fields, not-inspectable
   "./proxy" ->
      proxy, deprox, reprox
      setup-proxy, read-proxy, write-proxy
   .iter ->
      iterate-properties
   .directory ->
      Directory
   .relevant ->
      intersect, iterate-intersect, relevant-changes
   .root ->
      Root
   .dict ->
      Dict
   .tracks ->
      Tracks, Patch
   .cache ->
      arg-key, args-key
      cached-function
      State, DependentState
   .opaque ->
      opaque-cached-function


provide:
   identify, fork-identify, tuck
   ID, FORKID, VERSION, DIRECTORY
   methods, fields, not-inspectable
   Patch, Tracks
   proxy, deprox, reprox
   setup-proxy, read-proxy, write-proxy
   Directory
   iterate-properties
   intersect, iterate-intersect, relevant-changes
   Root
   args-key, arg-key
   cached-function
   opaque-cached-function
   State, DependentState
   ;; transact-all
   Dict
   object-clobber-helper
   array-clobber-helper
   ;; reactive
   ;; transact

;; macro{reactive-function2} reactive{expr} =
;;    let {"reactive-function2" => rfn} = @deps
;;    {system, it, self} = @mark{`system`, `@`, `self`}
;;    @multimacro with {
;;       project{match expr} =
;;          `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
;;             ```
;;             [^rfn]{_lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}}
;;             ```
;;          `^args -> ^body` ->
;;             ```
;;             [^rfn] with
;;                ^args ->
;;                   let ^it and ^self = this
;;                   ^body
;;             ```
;;          else ->
;;             print expr
;;             throw E.syntax.invalid-reactive{"invalid", node = expr}
;;    }

;; macro{transact-all} transact{#data{body}} =
;;    let {"transact-all" => tra} = @deps
;;    `[^tra] with {_} -> ^body`
