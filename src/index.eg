
require:
   .object-fill -> object-clobber-helper
   .array-fill -> array-clobber-helper
   .misc-fill
   .util ->
      tuck, identify, fork-identify, next-id
      ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
      methods, fields
   "./struct" ->
      make-struct, struct
   "./proxy" ->
      Patch, Tracks
      proxy, deprox, reprox
      setup-proxy, read-proxy, write-proxy
   .iter ->
      iterate-properties
   .directory ->
      Directory
   .relevant ->
      intersect, changed-relevantly
   .root ->
      Root
   "./reactive" ->
      System, reactive-function, reactive-function2
      current-system
      arg-key, args-key

      State, DependentState, transact-all
   .dict ->
      Dict

provide:
   identify, fork-identify, tuck
   ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   make-struct, struct
   Patch, Tracks
   proxy, deprox, reprox
   setup-proxy, read-proxy, write-proxy
   Directory
   iterate-properties
   changed-relevantly
   intersect
   Root
   args-key, arg-key
   System, reactive-function, reactive-function2
   State, DependentState
   transact-all
   current-system
   Dict
   object-clobber-helper
   array-clobber-helper

   reactive
   transact

macro{reactive-function2} reactive{expr} =
   let {"reactive-function2" => rfn} = @deps
   {system, it, self} = @mark{`system`, `@`, `self`}
   @multimacro with {
      project{match expr} =
         `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
            ```
            [^rfn]{_lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}}
            ```
         `^args -> ^body` ->
            ```
            [^rfn] with
               ^args ->
                  let ^it and ^self = this
                  ^body
            ```
         else ->
            print expr
            throw E.syntax.invalid-reactive{"invalid", node = expr}
   }

macro{transact-all} transact{#data{body}} =
   let {"transact-all" => tra} = @deps
   `[^tra] with {_} -> ^body`
