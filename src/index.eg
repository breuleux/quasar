
require:
   .object-fill -> object-clobber-helper
   .array-fill -> array-clobber-helper
   .misc-fill
   .util ->
      tuck, identify, fork-identify, next-id
      ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
      methods, fields
   "./struct" ->
      make-struct, struct
   "./proxy" ->
      proxy, deprox, reprox
      setup-proxy, read-proxy, write-proxy
   .iter ->
      iterate-properties
   .directory ->
      Directory
   .relevant ->
      ;; intersect, changed-relevantly
      intersect, iterate-intersect, relevant-changes
   .root ->
      Root
   ;; "./reactive" ->
   ;;    System, reactive-function, reactive-function2
   ;;    current-system
   ;;    arg-key, args-key

   ;;    State, DependentState, transact-all
   .dict ->
      Dict
   .tracks ->
      Tracks, Patch
   .cache ->
      arg-key, args-key
      cached-function
      opaque-cached-function
      State, DependentState

provide:
   identify, fork-identify, tuck
   ID, FORKID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   make-struct, struct
   Patch, Tracks
   proxy, deprox, reprox
   setup-proxy, read-proxy, write-proxy
   Directory
   iterate-properties
   ;; changed-relevantly
   intersect, iterate-intersect, relevant-changes
   Root
   args-key, arg-key
   ;; System, reactive-function, reactive-function2
   cached-function
   opaque-cached-function
   State, DependentState
   ;; transact-all
   ;; current-system
   Dict
   object-clobber-helper
   array-clobber-helper

   ;; reactive
   ;; transact

;; macro{reactive-function2} reactive{expr} =
;;    let {"reactive-function2" => rfn} = @deps
;;    {system, it, self} = @mark{`system`, `@`, `self`}
;;    @multimacro with {
;;       project{match expr} =
;;          `_lambda{^args, ^pre, ^body, ^post, ^gen}` ->
;;             ```
;;             [^rfn]{_lambda{^args, ^pre, [let ^it and ^self = this, ^body], ^post, ^gen}}
;;             ```
;;          `^args -> ^body` ->
;;             ```
;;             [^rfn] with
;;                ^args ->
;;                   let ^it and ^self = this
;;                   ^body
;;             ```
;;          else ->
;;             print expr
;;             throw E.syntax.invalid-reactive{"invalid", node = expr}
;;    }

;; macro{transact-all} transact{#data{body}} =
;;    let {"transact-all" => tra} = @deps
;;    `[^tra] with {_} -> ^body`
