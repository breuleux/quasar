

require:
   .directory ->
      Directory
   "./proxy" ->
      Patch
      proxy, deprox, reprox
   .relevant ->
      iterate-intersect
      intersect2
   .iter ->
      iterate-properties2
   .util ->
      identify, fork-identify, tuck
      next-id, fields, methods
      ID, FORKID, DIRECTORY, CACHE
   "./root" ->
      Root

provide:
   arg-key, args-key
   task-function
   opaque-task-function
   ;; System
   State, DependentState
   transact-all


;;;;;;;;;;;;;;
;; arg-keys ;;
;;;;;;;;;;;;;;

arg-key{match x} =
   ;; Translate some argument x to a string key.
   String? ->
      "S" + x
   null? or undefined? or Number? or Boolean? ->
      "P" + String{x}
   {^fields.opaque => true?} and identify! and fork-identify! ->
      "O" + String{x[ID]} + ":" + String{x[FORKID]}
   deprox! [x and {^ID => Number?}] ->
      fork-identify{x}
      "O" + String{x[ID]} + ":" + String{x[FORKID]}
   else ->
      '\x03{xs.join{"\x01"}}\x04' where
         xs = items{x} each {k, v} ->
            '{k}\x02{arg-key{v}}'

args-key{args} =
   ;; Translate a list of arguments to a string key.
   args.map{arg-key}.join{"\x00"}

get-replacement{match cached} =
   {=> replacement} ->
      get-replacement{replacement}
   else ->
      cached



;;;;;;;;;;;;
;; Tracks ;;
;;;;;;;;;;;;

;; {id => {key => {= n-tracks, = paths}}}

class Counter:
   constructor{} =
      @n-tracks = 0
   mark{} =
      @n-tracks += 1
   unmark{} =
      @n-tracks -= 1
   merge{other} =
      @n-tracks += other.n-tracks
   empty{} =
      @n-tracks <= 0
   size{} =
      1

;; class Chirurgies:
;;    constructor{} =
;;       @refs = {}
;;    mark{value} =
;;       @refs.push{value}
;;    merge-one{counts, entry} =
;;       if counts.n-tracks > 0:
;;          @refs.push{entry}
;;    merge{other} =
;;       @refs ++= other.refs
;;    unmerge-one{counts, entry} =
;;       match @refs.index-of{entry}:
;;          === -1 -> pass
;;          i ->
;;             @refs.splice{i, 1}
;;             @unmerge-one{counts, entry}
;;    unmerge{other} =
;;       ;; print @refs.length
;;       other.refs each entry ->
;;          match @refs.index-of{entry}:
;;             === -1 -> pass
;;             i ->
;;                @refs.splice{i, 1}
;;                @unmerge{other}
;;    unmerge-counts{other} =
;;       if other.n-tracks > 0:
;;          @refs = {}
;;    empty{} =
;;       @refs.length === 0



;; class Chirurgies:
;;    constructor{} =
;;       @refs = new Set{}
;;    mark{value} =
;;       @refs.add{value}
;;    merge-one{counts, entry} =
;;       if counts.n-tracks > 0:
;;          @refs.add{entry}
;;    merge{other} =
;;       other.refs each entry -> @refs.add{entry}
;;    unmerge-one{counts, entry} =
;;       @refs.delete{entry}
;;    unmerge{other} =
;;       other.refs each entry -> @refs.delete{entry}
;;    unmerge-counts{other} =
;;       if other.n-tracks > 0:
;;          @refs = new Set{}
;;    empty{} =
;;       @refs.size === 0
;;    size{} =
;;       @refs.size



class Chirurgies:
   constructor{} =
      @refs = new Map{}
   mark{{g, c}} =
      @refs.set{g, c}
   merge-one{counts, {g, c}} =
      if counts.n-tracks > 0:
         @refs.set{g, c}
   merge{other} =
      other.refs.entries{} each {g, c} -> @refs.set{g, c}
   unmerge-one{counts, {g, _}} =
      @refs.delete{g}
   unmerge{other} =
      other.refs.entries{} each {g, _} -> @refs.delete{g}
   unmerge-counts{other} =
      if other.n-tracks > 0:
         @refs = new Map{}
   empty{} =
      @refs.size === 0
   size{} =
      @refs.size


class Tracks:

   constructor{@factory = Counter} =
      @data = {=}

   get{id} =
      id and [@data[id] or= {=}]
   get-for{obj} =
      if not obj: return null
      id = obj[ID]
      id and [@data[id] or= {=}]

   list{} =
      items{@data}
   empty{} =
      return keys{@data}.length === 0

   mark{obj, key} =
      tracks = @get-for{obj}
      if not tracks:
         return
      t = [tracks[key] or= @factory{}]
      t.mark{}
      ;; t = [tracks[key] or= {n-tracks = 0}]
      ;; t.n-tracks += 1

   unmark{obj, key} =
      tracks = @get-for{obj}
      if not tracks:
         return
      t = tracks[key]
      t.unmark{}
      if t.empty{}:
         delete tracks[key]
      ;; tracks[key].n-tracks -= 1

   merge{tracks, merger = .merge, arg = null} =
      items{tracks.data} each {id, v} ->
         v0 = [@data[id] or= {=}]
         items{v} each {key, obj} ->
            obj0 = [v0[key] or= @factory{}]
            obj0[merger]{obj, arg}
            if obj0.empty{}:
               delete v0[key]
         if keys{v0}.length === 0:
            delete @data[id]
            ;; obj0 = [v0[key] or= {n-tracks = 0}]
            ;; obj0.n-tracks += obj.n-tracks

   register{obj, key, fn} =
      val = fn{}
      if val !== true:
         throw E.cannot-assimilate-tracks{fn{}}
      @mark{obj, key}

   size{} =
      var sz = 0
      items{@data} each {id, ob} ->
         items{ob} each {k, v} ->
            sz += v.size{}
      sz

;;;;;;;;;;;;
;; Opaque ;;
;;;;;;;;;;;;

contents = Symbol{"contents"}

extract-opaque{match x} =
   Opaque? -> x[contents]
   else -> x

class Opaque:
   constructor{value} =
      @[contents] = value
   [^methods.iterate-properties]{} =
      {{contents, @[contents], null}}
   [^methods.fork]{dir} =
      rval = Opaque{null}
      {ID, CACHE} each field ->
         tuck{rval, field, @[field]}
      fork-identify{rval}
      dir.enter{rval, false}
      rval[contents] = dir.acquire{@[contents]}
      rval

   ;; [^methods.iterate-properties2]{} =
   ;;    {{contents, @[contents], null, null}}


;;;;;;;;;;;;;;;;;;
;; CachedResult ;;
;;;;;;;;;;;;;;;;;;

class CachedResult:

   constructor{@reactor, @self, @args, @value, @tracks, @version} =
      ;; @opaque-children = {}
      @direct-tracks = Tracks{Chirurgies}
      @GRRR = #boo{next-id{}}
      tuck{@value, CACHE, @}
      if Opaque? @value:
         tuck{extract-opaque{@value}, CACHE, @}
      @walk{if{Opaque? @value, @value[contents], @value}}
      @direct-tracks.merge{@tracks, .unmerge-counts}

   walk{identify! v} =
      ;; print if{Opaque? v, v[contents]}
      iterate-properties2{v} each
         {k, match obj, setter, gen-patch, ignore-children = false} ->
            match Opaque? opq ->
               do:
                  setter{opq[contents]}
               {^CACHE => cache} when cache ->
                  ;; tuck{opq[contents], CACHE, cache}
                  ;; @opaque-children.push with {opq, v, k}
                  @direct-tracks.merge{cache.tracks, .merge-one} with
                     {'{v[ID]}\x00{k}', {v, k, gen-patch, cache}}
                  @direct-tracks.merge{cache.direct-tracks}
               else ->
                  pass
            {^CACHE => cache} when cache ->
               @direct-tracks.merge{cache.direct-tracks}
            else ->
               @walk{obj}

   unwalk{v, parent, k, var cache = null} =
      cache or= v[CACHE]
      if cache:
         @direct-tracks.merge{cache.tracks, .unmerge-one, {'{parent[ID]}\x00{k}', null}}
         ;; cache.opaque-children each {v2, parent2, k2} ->
         ;;    @unwalk{v2, parent2, k2}
      iterate-properties2{v} each
         {k, obj, setter, gen-patch, ignore-children = false} ->
            @unwalk{obj, v, k}

   update{} =
      current-context{} as {
         ;; => root
         => patch
         => out-patch
         dir => let dir and {=> version}
      }
      if not patch:
         return [@]
      match version:
         == @version or when not @version ->
            @
         when @tracks and intersect2{@tracks, patch, dir} ->
            rval and @replacement = @reactor.render{@self, @args, true}
            rval
         else ->
            var nin and nout = 0
            done = new Set{}
            todo = iterate-intersect{@direct-tracks, patch, dir} each {=> refs} ->
               refs.entries{} each x -> x
            sz0 = @direct-tracks.size{}
            todo each refs -> refs each
               entry and {key, {v, k, genp, cache}} ->
                  ;; outs
                  nout += cache.direct-tracks.size{} ;;1
                  @direct-tracks.merge{cache.tracks, .unmerge-one, entry}
                  ;; @direct-tracks.merge{cache.direct-tracks, .unmerge}
                  @unwalk{extract-opaque{cache.value}, v, k, cache}
            sz1 = @direct-tracks.size{}

            todo each refs -> refs each
               entry and {key, {v, k, genp, cache}} when not done.has{entry} ->
                  done.add{entry}
                  new-cache = cache.update{}
                  ;; ins
                  nin += new-cache.direct-tracks.size{} ;;1
                  @direct-tracks.merge{new-cache.tracks, .merge-one} with
                     {key, {v, k, genp, new-cache}}
                  @direct-tracks.merge{new-cache.direct-tracks}
                  genp{out-patch, extract-opaque{new-cache.value}}
            sz2 = @direct-tracks.size{}
            @direct-tracks.merge{@tracks, .unmerge-counts}
            sz3 = @direct-tracks.size{}

            print {sz0, sz1, sz2, sz3, {nout, nin}}
            @

            ;; outs = {}
            ;; ins = {}
            ;; iterate-intersect{@direct-tracks, patch, dir} each
            ;;    {=> refs} ->
            ;;       refs each entry and {genp, cache} ->
            ;;          outs.push with entry
            ;;          new-cache = cache.update{}
            ;;          ins.push with {genp, new-cache}
            ;;          genp{out-patch, extract-opaque{new-cache.value}}

            ;; outs each entry and {genp, cache} ->
            ;;    @direct-tracks.merge{cache.tracks, .unmerge-one, entry}
            ;;    @direct-tracks.merge{cache.direct-tracks, .unmerge}
            ;; ins each {genp, cache} ->
            ;;    @direct-tracks.merge{cache.tracks, .merge-one, {genp, cache}}
            ;;    @direct-tracks.merge{cache.direct-tracks}
            ;; @



            ;; ;; outs = {}
            ;; ;; ins = {}
            ;; done = new Set{}
            ;; todo = iterate-intersect{@direct-tracks, patch, dir} each
            ;;    {=> refs} -> refs each x -> x
            ;; todo each entry and {genp, cache} when not done.has{entry} ->
            ;;    done.add{entry}
            ;;    ;; out
            ;;    @direct-tracks.merge{cache.tracks, .unmerge-one, entry}
            ;;    @direct-tracks.merge{cache.direct-tracks, .unmerge}
            ;;    new-cache = cache.update{}
            ;;    ;; in
            ;;    @direct-tracks.merge{new-cache.tracks, .merge-one, {genp, new-cache}}
            ;;    @direct-tracks.merge{new-cache.direct-tracks}
            ;;    genp{out-patch, extract-opaque{new-cache.value}}

            ;; ;; outs each entry and {genp, cache} ->
            ;; ;;    @direct-tracks.merge{cache.tracks, .unmerge-one, entry}
            ;; ;;    @direct-tracks.merge{cache.direct-tracks, .unmerge}
            ;; ;; ins each {genp, cache} ->
            ;; ;;    @direct-tracks.merge{cache.tracks, .merge-one, {genp, cache}}
            ;; ;;    @direct-tracks.merge{cache.direct-tracks}
            ;; print @direct-tracks.size{}
            ;; @

         ;; else ->
         ;;    dirty = @tracks and intersect2{@tracks, patch, dir}
         ;;    if not dirty:
         ;;       return [@]
         ;;    rval and @replacement = @reactor.render{@self, @args, true}
         ;;    rval

   ;; update{patch, dir and {version => match}} =
   ;;    == @version or when not @version ->
   ;;       @
   ;;    else ->
   ;;       dirty = @tracks and intersect2{@tracks, patch, dir}
   ;;       if not dirty:
   ;;          return [@]
   ;;       rval and @replacement = @reactor.render{@self, @args}
   ;;       rval


;; var context = null
frame-stack = {}

current-frame{} =
   frame-stack[frame-stack.length - 1]

current-context{} =
   current-frame{}??.context

with-frame{frame, fn} =
   frame-stack.push{frame}
   res = fn{}
   frame-stack.pop{}
   res

class Frame:
   constructor{@tracks, context = {=}} =
      prev = [current-context{} or {=}]
      @context = [prev & {root = false}] & context

   ;; constructor{@fn} =
   ;;    pass

   ;; execute{} =
   ;;    parent = current-frame{}
   ;;    frame-stack.push{@}
   ;;    @cache and {tracks => @tracks, value => @value} = @fn{}
   ;;    frame-stack.pop{}
   ;;    print parent
   ;;    parent??.tracks.merge{@tracks}
   ;;    @



   ;; constructor{@fn, @self, @args} =
   ;;    @tracks = Tracks{}

   ;; execute{} =
   ;;    {=> patch, => var dir} = context

   ;;    pargs = @args each arg -> _reprox{arg, @tracks}
   ;;    pself = _reprox{@self, @tracks}

   ;;    ;; {=> version = null} = deps[DIRECTORY]
   ;;    ;; res = identify{@renderfn.apply{self-prox, pargs}}
   ;;    ;; cached = CachedResult{@, @self, @args, res, deps, version}
   ;;    ;; cached

   ;;    parent = @current-frame{}
   ;;    frame-stack.push{@}
   ;;    @result = @fn.call{pself, pargs}
   ;;    frame-stack.pop{}
   ;;    parent??.tracks.merge{@tracks}
   ;;    @


_reprox{match x, deps} =
   {^ID => Number?} or null? or undefined? or {^fields.opaque => true?} ->
      reprox{x, deps, null}
   Array? ->
      x each y -> _reprox{y, deps}
   else ->
      rval = Object.create{Object.get-prototype-of{x}}
      items{x} each {k, v} ->
         rval[k] = _reprox{v, deps}
      rval

class Reactor:

   constructor{@renderfn, @opaque = false} =
      @argmap = {=}

   render{the-self, args, force = false} =
      key = args-key{{the-self} ++ args}
      cached =
         match @argmap[key]:
            undefined? or when force ->
               @render-cache-object{the-self, args}
            cached ->
               c = get-replacement{cached}
               c.update{}
      @argmap[key] = cached
      parent = current-frame{}
      if not @opaque:
         parent??.tracks.merge{cached.tracks}
      cached

   render-cache-object{the-self, args} =
      tracks = Tracks{}
      pargs = args each arg -> _reprox{arg, tracks}
      pself = reprox{the-self, tracks, null}
      {
         dir => {=> version = null}
         => out-dir
      } = current-context{}

      ;; frame-stack.push{Frame{tracks}}
      ;; res = identify{@renderfn.apply{pself, pargs}}
      ;; frame-stack.pop{}
      var res = with-frame{Frame{tracks}} with ->
         identify{@renderfn.apply{pself, pargs}}

      if @opaque:
         res = identify{Opaque{res}}
      res = out-dir.acquire{res}

      cached = CachedResult{@, the-self, args, res, tracks, version}
      cached



      ;; deps = Tracks{}
      ;; pargs = args each arg -> _reprox{arg, deps}
      ;; pself = reprox{the-self, deps, null}
      ;; {=> version = null} = context.dir ;; deps[DIRECTORY]
      ;; res = identify{@renderfn.apply{pself, pargs}}
      ;; cached = CachedResult{@, the-self, args, res, deps, version}
      ;; cached

      ;; frame = Frame{@renderfn, the-self, args}
      ;; {=> tracks, => result} = frame.execute{}
      ;; ;; res = identify{@renderfn.apply{self-prox, pargs}}
      ;; {dir => {=> version}} = context
      ;; cached = CachedResult{@, the-self, args, result, tracks, version}
      ;; cached



;;;;;;;;;;;
;; State ;;
;;;;;;;;;;;

class State:

   constructor{@origin, @options = {=}} =
      {clobber-patch => @clobber-patch = false} = @options
      @listeners = {}

      @patch-stack = {}
      @patch = Patch{}

      @dir = Directory{clobber-patch = @clobber-patch}
      @basis = @dir.acquire-copy{@origin}
      @basis-proxy = proxy{@basis, null, @patch}
      @patch.shift{}

      State.all.push{@}

   add-listener{listener} =
      @listeners.push with listener

   get{} =
      @basis

   model{} =
      @basis-proxy

   commit{} =
      patch = Patch{@patch.shift{}}
      @dir.patch{patch}
      @listeners each listener ->
         listener{@model{}, patch}
      true

   transact{fn} =
      fn{@model{}}
      @commit{}

State.all = {}

var is-transaction = false

transact-all{fn} =
   commit = not is-transaction
   is-transaction = true
   try:
      fn{}
      if commit:
         State.all each state ->
            state.commit{}
   finally:
      if commit:
         is-transaction = false



;;;;;;;;;;;;;;;;;;;;
;; DependentState ;;
;;;;;;;;;;;;;;;;;;;;

class DependentState < State:

   constructor{@input, @render, @options = {=}} =

      {clobber-patch => @clobber-patch = true
       action => @action = {x} -> x} = @options
      @listeners = {}

      @patch-stack = {}
      @patch = Patch{}

      @dir = Directory{clobber-patch = @clobber-patch}

      @redo = true
      @compute{}

      @input.add-listener{@listen.bind{@}}

      State.all.push{@}

   compute{patch = null} =
      if not @redo and @_previous-input !== @input.get{}:
         @redo = true
      @_previous-input = @input.get{}
      @basis =
         with-frame{Frame{Tracks{}, context}, fn} where
            context = {
               state = @input
               patch = patch
               dir = @input.dir
               out-patch = @patch
               out-dir = @dir
               root = true
            }
            fn{} =
               if @redo:
                  @redo = false
                  @render.rend.call{null, @input.model{}}
               else:
                  @basis = @basis.update{}
                  @basis
      ;; @basis.value = @dir.acquire{@basis.value}

   get{} =
      ;; print @basis.direct-tracks.data
      match @basis.value:
         Opaque? x -> x[contents]
         v -> v

   model{} =
      proxy{@basis.value, null, @patch}

   listen{model, patch} =
      @compute{patch}
      ;; print @patch.data
      ;; print @basis.value
      ;; print @basis.value[ID]
      ;; print @basis.value[contents]??[ID]
      @commit{}
      ;; print @basis.value

   ;; compute{} =
   ;;    @_previous-input = @input.get{}
   ;;    rend = with-frame{Frame{Tracks{}, context}, fn} where
   ;;       context = {
   ;;          patch = null
   ;;          state = @input
   ;;          dir = @input.dir
   ;;       }
   ;;       fn{} =
   ;;          @render.call{null, @input.model{}}

   ;;    r = @dir.acquire with Root{rend, @action, true}
   ;;    @basis = CachedResult{null, null, null, r, null}

   ;;    ;; rend = with-state{@, -> @render.call{null, @input.model{}}}
   ;;    ;; r = @dir.acquire with
   ;;    ;;    Root{rend, @action, true}
   ;;    ;; @basis = CachedResult{null, null, null, r, null}



;; ;;;;;;;;;;;;
;; ;; System ;;
;; ;;;;;;;;;;;;


;; class System:

;;    constructor{@origin, @render, @options = {=}} =
;;       ;; identify{@}
;;       ;; fork-identify{@}
;;       {clobber-patch => @clobber-patch = true
;;        action => @action = {x} -> x} = @options

;;       @patch-stack = {}
;;       @patch = Patch{}

;;       @bdir = Directory{}
;;       @basis = @bdir.acquire-copy{@origin}
;;       @basis.__SYSTEM = [@]
;;       @basis-proxy = proxy{@basis, null, @patch}

;;       @result =
;;          with-frame{Frame{Tracks{}, context}, fn} where
;;             context = {
;;                patch = @patch
;;                dir = @bdir
;;             }
;;             fn{} =
;;                r = @render{@basis-proxy}
;;                ;; print current-frame{}.tracks.data
;;                r

;;    get{} =
;;       @result



;;;;;;;;;;;;;;;;;;;
;; task-function ;;
;;;;;;;;;;;;;;;;;;;

task-function{render, opaque = false} =
   r = Reactor{render, opaque}
   mkcache{args} =
      r.render{this or current-context{}.state, args}
   rval{*args} = mkcache{args}.value
   rval.orig = render
   rval.reactor = r
   rval.rend{*args} = mkcache{args}
   rval

opaque-task-function{render} =
   task-function{render, true}

