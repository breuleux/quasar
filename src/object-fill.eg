
require:
   .util ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   .proxy ->
      deprox
   ;; .iter ->
   ;;    iterate-properties
   ;;    iterate-properties2

provide:
   object-clobber-helper


;;;;;;;;;;
;; FORK ;;
;;;;;;;;;;

method Object.prototype[methods.fork]{dir} =
   rval = Object.create{Object.get-prototype-of{@}}
   items{@} each {key, value} ->
      rval[key] = @[key]
   rval


;;;;;;;;;;;
;; PATCH ;;
;;;;;;;;;;;

Object.prototype[methods.patch]{p, dir, wrapper = this} =
   obj = this
   identify{wrapper}
   match p.get-for{wrapper}:
      undefined? -> pass
      items! [each {field, match}] ->
         #update{deprox! value} ->
            obj[field] = dir.replace{obj[field], value}
         #delete{} ->
            dir.exit{obj[field]}
            delete obj[field]
   obj


;;;;;;;;;;;;;
;; CLOBBER ;;
;;;;;;;;;;;;;

object-clobber-helper{obj, new-obj, items, owns} =
   operations = {}
   items{obj} each
      {k, v} when not owns{new-obj, k} ->
         operations.push with #delete{k}
   items{new-obj} each {k, match v} ->
      do: v0 = obj[k]
      === v0 or when v0 and v0[ID] and v and v[ID] == v0[ID] ->
         pass
      else ->
         operations.push with #put{k, v}
   operations

Object.prototype[methods.clobber]{new-obj, dir} =
   obj = this

   if Object.get-prototype-of{obj} !== Object.get-prototype-of{new-obj}:
      return dir.replace{obj, new-obj, false}

   dir.unlist{obj}

   object-clobber-helper{
      obj, new-obj, items
      {a, b} -> Object.has-own-property.call{a, b}
   } each
      #delete{k} ->
         dir.exit{obj[k]}
         delete obj[k]
      #put{k, v} ->
         obj[k] = dir.clobber{obj[k], v}

   tuck{obj, ID, new-obj[ID]}

   dir.list{obj}

   obj


;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATE-PROPERTIES ;;
;;;;;;;;;;;;;;;;;;;;;;;;

Object.prototype[methods.iterate-properties]{wrapper = this} =
   obj = this
   id = wrapper[ID]
   items{obj} each {k, v} ->
      {k, v, gen-patch} where
         gen-patch{patch, new-v} =
            patch.get{id}[k] = #update{new-v}

Object.prototype[methods.iterate-properties2]{wrapper = this} =
   obj = this
   id = wrapper[ID]
   items{obj} each {k, v} ->
      {k, v, setter, gen-patch} where
         setter{new-v} =
            obj[k] = new-v
         gen-patch{patch, new-v} =
            patch.get{id}[k] = #update{new-v}


;;;;;;;;;;;;;;;;;;;;;;;;
;; CHANGED-RELEVANTLY ;;
;;;;;;;;;;;;;;;;;;;;;;;;

Object.prototype[methods.changed-relevantly]{reads, writes} =
   items{writes or {=}} each
      {name, _} when reads[name] ->
         return true
   false

Object.prototype[methods.changed-relevantly2]{reads, writes} =
   items{writes or {=}} each
      {name, _} when reads[name]??.n-tracks ->
         return true
   false

gen Object.prototype[methods.relevant-changes]{reads, writes} =
   items{writes or {=}} each
      {name, _} and r is reads[name] when r and not r.empty{} ->
         yield reads[name]

