
require:
   .util ->
      identify, fork-identify, tuck
      next-id, ID
      methods
      longest-run
   .proxy ->
      deprox

provide:
   object-clobber-helper


;; ;;;;;;;;;;
;; ;; FORK ;;
;; ;;;;;;;;;;

;; method Object.prototype[methods.fork]{dir} =
;;    rval = Object.create{Object.get-prototype-of{@}}
;;    items{@} each {key, value} ->
;;       rval[key] = @[key]
;;    rval


;; ;;;;;;;;;;;
;; ;; PATCH ;;
;; ;;;;;;;;;;;

;; Object.prototype[methods.patch]{p, dir, wrapper = this} =
;;    obj = this
;;    identify{wrapper}
;;    match p.get-for{wrapper}:
;;       undefined? -> pass
;;       items! [each {field, match}] ->
;;          #update{deprox! value} ->
;;             obj[field] = dir.replace{obj[field], value}
;;          #delete{} ->
;;             dir.exit{obj[field]}
;;             delete obj[field]
;;    obj


;;;;;;;;;;;;;
;; CLOBBER ;;
;;;;;;;;;;;;;

object-clobber-helper{obj, new-obj, items, owns} =
   operations = {}
   items{obj} each
      {k, v} when not owns{new-obj, k} ->
         operations.push with #delete{k}
   items{new-obj} each {k, match v} ->
      do: v0 = obj[k]
      === v0 or when v0 and v0[ID] and v and v[ID] == v0[ID] ->
         pass
      else ->
         operations.push with #put{k, v}
   operations

Object.prototype[methods.clobber]{new-obj, dir} =
   obj = this

   if Object.get-prototype-of{obj} !== Object.get-prototype-of{new-obj}:
      return dir.replace{obj, new-obj, false}

   dir.unlist{obj}

   object-clobber-helper{
      obj, new-obj, items
      {a, b} -> Object.has-own-property.call{a, b}
   } each
      #delete{k} ->
         dir.exit{obj[k]}
         delete obj[k]
      #put{k, v} ->
         obj[k] = dir.clobber{obj[k], v}

   tuck{obj, ID, new-obj[ID]}

   dir.list{obj}

   obj


;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATE-PROPERTIES ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;; Object.prototype[methods.set]{k, value} =
;;    this[k] = value

;; Object.prototype[methods.iterate-properties]{wrapper = this} =
;;    obj = this
;;    id = wrapper[ID]
;;    items{obj} each {k, v} ->
;;       {k, v, setter} where
;;          setter{new-v} =
;;             obj[k] = new-v


;;;;;;;;;;;;;;;;;;;;;;;;
;; CHANGED-RELEVANTLY ;;
;;;;;;;;;;;;;;;;;;;;;;;;

gen Object.prototype[methods.relevant-changes]{reads, writes} =
   items{writes or {=}} each
      {name, _} and r is reads[name] when r??.not-empty{} ->
         yield r

