
provide:
   tuck, opaque
   ID, CLOBBERID, FORKID, PROTOID, VERSION, SOURCE, DIRECTORY, CACHE
   methods, fields
   next-id, identify, fork-identify
   longest-run
   timeit

tuck{obj, name, value, writable = true} =
   if obj and Object? obj:
      Object.define-property{obj, name} with {
         value = value
         enumerable = false
         writable = writable
         configurable = true
      }

predicate! opaque{match} =
   null? or undefined? or {fields.opaque => true?} ->
      true
   else ->
      false



ID = Symbol{.id}
FORKID = Symbol{.forkid}
PROTOID = Symbol{.protoid}
VERSION = Symbol{.version}
SOURCE = Symbol{.source}
CLOBBERID = Symbol{.clobberid}
DIRECTORY = Symbol{.directory}
CACHE = Symbol{.cache}

methods = {
   proxy = Symbol{.proxy}
   iterate-properties = Symbol{.iterate-properties}
   iterate-properties2 = Symbol{.iterate-properties2}
   fork = Symbol{.fork}
   patch = Symbol{.patch}
   clobber = Symbol{.clobber}
   changed-relevantly = Symbol{.changed-relevantly}
   changed-relevantly2 = Symbol{.changed-relevantly2}
   relevant-changes = Symbol{.relevant-changes}
   register-tracks = Symbol{.register-tracks}
   register-patch = Symbol{.register-patch}
   check-dirty-read = Symbol{.check-dirty-read}
   key = Symbol{.key}
}

fields = {
   obj = Symbol{.obj}
   tracks = Symbol{.tracks}
   patch = Symbol{.patch}
   prevent-dirty-reads = Symbol{.prevent-dirty-reads}
   system = Symbol{.system}
   opaque = Symbol{.opaque}
   structural = Symbol{.structural}
   key = Symbol{.key}
   cache = Symbol{.cache}
}


var _id = 0

next-id{} =
   _id += 1
   _id

identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[ID] ->
      x
   else ->
      tuck{x, ID, next-id{}}
      x

fork-identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[FORKID] ->
      x
   else ->
      tuck{x, FORKID, next-id{}}
      x



;; longest-run{match indices, cmp = {x, y} -> x < y, minimum = -1} =
;;    {} -> {}
;;    {match x, *rest} ->
;;       do: baseline = longest-run{rest, cmp, minimum}
;;       null? or when not cmp{minimum, x} ->
;;          baseline
;;       when baseline.length > 0 and cmp{x, baseline[0]} ->
;;          baseline.unshift{x}
;;          baseline
;;       else ->
;;          rval = longest-run{rest, cmp, x}
;;          if rval.length < baseline.length:
;;             baseline
;;          else:
;;             rval.unshift{x}
;;             rval

longest-run{indices, cmp = {x, y} -> x < y, minimum = -1} =
   cache = {=}
   helper{i, minimum} =
      key = '{i}/{minimum}'
      if cache[key]:
         return cache[key]
      r =
         if i == indices.length:
            {}
         else:
            x = indices[i]
            baseline = helper{i + 1, minimum}
            if x === null or not cmp{minimum, x}:
               baseline
            elif baseline.length > 0 and cmp{x, baseline[0]}:
               ;; baseline.unshift{x}
               ;; baseline
               {x} ++ baseline
            else:
               rval = helper{i + 1, x}
               if rval.length < baseline.length:
                  baseline
               else:
                  ;; rval.unshift{x}
                  ;; rval
                  {x} ++ rval
      cache[key] = r
      r
   helper{0, minimum}


macro timeit{`{^iters, ^body}` or `{^body}` and iters is `1`} =
   ```
   iters = ^iters
   start = +[new Date{}]
   1..iters each _ ->
      ^body
   end = +[new Date{}]
   [end - start] / iters
   ```

