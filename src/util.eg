
provide:
   tuck, not-inspectable
   ID, FORKID, PROTOID, VERSION, DIRECTORY
   methods, fields
   next-id, identify, fork-identify
   longest-run
   timeit

tuck{obj, name, value, writable = true} =
   if obj and Object? obj:
      Object.define-property{obj, name} with {
         value = value
         enumerable = false
         writable = writable
         configurable = true
      }

predicate! not-inspectable{match} =
   null? or undefined? or {fields.not-inspectable => true?} ->
      true
   else ->
      false



methods = {
   proxy = Symbol{.proxy}
   iterate-properties = Symbol{.iterate-properties}
   fork = Symbol{.fork}
   patch = Symbol{.patch}
   clobber = Symbol{.clobber}
   relevant-changes = Symbol{.relevant-changes}
   register-tracks = Symbol{.register-tracks}
   register-patch = Symbol{.register-patch}
   check-dirty-read = Symbol{.check-dirty-read}
   key = Symbol{.key}
   enter = Symbol{.enter}
   exit = Symbol{.exit}
   get = Symbol{.get}
   set = Symbol{.set}
}

fields = {
   id = Symbol{.id}
   forkid = Symbol{.forkid}
   protoid = Symbol{.protoid}
   version = Symbol{.version}
   source = Symbol{.source}
   clobberid = Symbol{.clobberid}
   directory = Symbol{.directory}

   obj = Symbol{.obj}
   tracks = Symbol{.tracks}
   patch = Symbol{.patch}
   prevent-dirty-reads = Symbol{.prevent-dirty-reads}
   system = Symbol{.system}
   not-inspectable = Symbol{.not-inspectable}
   structural = Symbol{.structural}
   key = Symbol{.key}
   cache = Symbol{.cache}
   associated-state = Symbol{.associated-state}
}

ID = fields.id
FORKID = fields.forkid
PROTOID = fields.protoid
VERSION = fields.version
DIRECTORY = fields.directory


var _id = 0

next-id{} =
   _id += 1
   _id

identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[ID] ->
      x
   else ->
      tuck{x, ID, next-id{}}
      x

fork-identify{match x} =
   null? or undefined? or Number? or String? or Symbol? or Boolean? ->
      x
   when x[FORKID] ->
      x
   else ->
      tuck{x, FORKID, next-id{}}
      x


longest-run{indices, cmp = {x, y} -> x < y, minimum = -1} =
   cache = {=}
   helper{i, minimum} =
      key = '{i}/{minimum}'
      if cache[key]:
         return cache[key]
      r =
         if i == indices.length:
            {}
         else:
            x = indices[i]
            baseline = helper{i + 1, minimum}
            if x === null or not cmp{minimum, x}:
               baseline
            elif baseline.length > 0 and cmp{x, baseline[0]}:
               ;; baseline.unshift{x}
               ;; baseline
               {x} ++ baseline
            else:
               rval = helper{i + 1, x}
               if rval.length < baseline.length:
                  baseline
               else:
                  ;; rval.unshift{x}
                  ;; rval
                  {x} ++ rval
      cache[key] = r
      r
   helper{0, minimum}


macro timeit{`{^iters, ^body}` or `{^body}` and iters is `1`} =
   ```
   iters = ^iters
   start = +[new Date{}]
   1..iters each _ ->
      ^body
   end = +[new Date{}]
   [end - start] / iters
   ```
