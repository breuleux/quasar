
require:
   .util ->
      methods

provide:
   intersect, iterate-intersect, relevant-changes


intersect{tracks, patch, dir} =
   iterate-intersect{tracks, patch, dir} each x ->
      return true
   false

gen iterate-intersect{tracks, patch, dir} =
   patch.list{} each {id, writes} ->
      obj = dir.get{id}
      reads = tracks.get{id}
      if reads:
         yield all relevant-changes{obj, reads, writes}

relevant-changes{match value, reads, writes} =
   ;; TODO: investigate why value might be null despite the presence
   ;; of reads and writes.
   {^methods.relevant-changes => Function?} ->
      value[methods.relevant-changes]{reads, writes}
   else ->
      Object.prototype[methods.relevant-changes].call{value, reads, writes}
