
require:
   .util ->
      SOURCE, methods

provide:
   intersect, changed-relevantly
   intersect2, changed-relevantly2
   iterate-intersect, relevant-changes


intersect{tracks, patch, dir} =
   patch.list{} each {id, writes} ->
      obj = dir.get{id}
      reads = tracks.get{id}
      if reads and changed-relevantly{obj, reads, writes}:
         return true
   false


changed-relevantly{match value, reads, writes} =
   ;; TODO: investigate why value might be null despite the presence
   ;; of reads and writes.
   {^methods.changed-relevantly => Function?} ->
      value[methods.changed-relevantly]{reads, writes}
   else ->
      Object.prototype[methods.changed-relevantly].call{value, reads, writes}




intersect2{tracks, patch, dir} =
   patch.list{} each {id, writes} ->
      obj = dir.get{id}
      reads = tracks.get{id}
      if reads and changed-relevantly2{obj, reads, writes}:
         return true
   false


changed-relevantly2{match value, reads, writes} =
   ;; TODO: investigate why value might be null despite the presence
   ;; of reads and writes.
   {^methods.changed-relevantly2 => Function?} ->
      value[methods.changed-relevantly2]{reads, writes}
   else ->
      Object.prototype[methods.changed-relevantly2].call{value, reads, writes}




gen iterate-intersect{tracks, patch, dir} =
   patch.list{} each {id, writes} ->
      obj = dir.get{id}
      reads = tracks.get{id}
      if reads:
         yield all relevant-changes{obj, reads, writes}

relevant-changes{match value, reads, writes} =
   ;; TODO: investigate why value might be null despite the presence
   ;; of reads and writes.
   {^methods.relevant-changes => Function?} ->
      value[methods.relevant-changes]{reads, writes}
   else ->
      Object.prototype[methods.relevant-changes].call{value, reads, writes}
