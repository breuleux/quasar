
require:
   .object-fill -> object-clobber-helper
   .array-fill -> array-clobber-helper
   .misc-fill
   .util ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   .proxy ->
      deprox
   .iter ->
      iterate-properties
      iterate-properties2

provide:
   Directory
   object-clobber-helper
   array-clobber-helper


class Directory:

   constructor{@options = {=}} =
      ;; Tie @duplicate to @clobber-patch by default, since they should
      ;; usually have the same value.
      @options as {
         clobber-patch => @clobber-patch = false
         duplicate => @duplicate = @clobber-patch
         assimilate => @assimilate = false
      }
      @dir = {=}
      @version = 1

   ;;;;;;;;;;;;;
   ;; GETTERS ;;
   ;;;;;;;;;;;;;

   get-all{id} =
      match @dir[id]:
         undefined? -> {}
         {_, v} -> {v}
         objs -> items{objs} each {k, v} -> v

   get{id} =
      @get-all{id}[0]

   get-canon{v} =
      v and v[ID] and @get{v[ID]} or v

   ;;;;;;;;;;;;;;;;;
   ;; LIST/UNLIST ;;
   ;;;;;;;;;;;;;;;;;

   list{deprox! value} =
      id = value[ID]
      if @duplicate:
         sub = [@dir[id] or= {=}]
         sub[value[FORKID]] = value
      else:
         @dir[id] =
            match @dir[id]:
               undefined?     -> {1, value}
               {count, value} -> {count + 1, value}

   unlist{deprox! v} =
      id = v[ID]
      if @duplicate:
         sub = @dir[id]
         delete sub[v[FORKID]]
      else:
         {count, _} = @dir[id]
         match count:
            > 1 ->
               @dir[id] = {count - 1, v}
               return v
            else ->
               delete @dir[id]
               delete v[DIRECTORY]

   ;;;;;;;;;;;;;;;;
   ;; ENTER/EXIT ;;
   ;;;;;;;;;;;;;;;;

   enter{deprox! match v} =
      null? or undefined? or Number? or String? or Symbol? or Boolean? ->
         v
      else ->
         x = @get-canon{v}
         var enter-children = true
         value = match x:
            when @duplicate ->
               @fork{x}
            {^DIRECTORY => match} ->
               === [@] ->
                  enter-children = false; x
               else ->
                  @fork{x}
            when @assimilate ->
               identify{x}
               x
            else ->
               @fork{x}

         tuck{value, DIRECTORY, @}
         fork-identify{value}
         @list{value}
         if enter-children:
            iterate-properties2{value} each
               {k, v2, setter, replace} ->
                  newv = @enter{v2}
                  if newv !== v2:
                     setter{newv}
         value

   exit{deprox! match v} =
      null? or undefined? or Number? or String? or Symbol? or Boolean? ->
         v
      else ->
         @unlist{v}
         iterate-properties2{v} each
            {k, v2, setter, replace} ->
               @exit{v2}

   ;;;;;;;;;;;;;
   ;; ACQUIRE ;;
   ;;;;;;;;;;;;;

   acquire{v} =
      @enter{v}

   ;;;;;;;;;;
   ;; FORK ;;
   ;;;;;;;;;;

   fork{match value} =
      null? or undefined? ->
         value
      do:
         identify{value}
      else ->
         rval = deprox{value}[methods.fork]{@}
         {ID, CACHE} each field ->
            tuck{rval, field, value[field]}
         fork-identify{rval}
         rval

   clobber{match value, new-value} =
      null? or undefined? ->
         new-value
      do:
         identify! value
         identify! new-value
      when value[ID] and value[ID] === new-value[ID] ->
         value
      else ->
         deprox{value}[methods.clobber]{new-value, @}

   replace{old-value, new-value} =
      if @clobber-patch:
         @clobber{old-value, @get-canon{new-value}}
      else:
         v = @acquire{new-value}
         @exit{old-value}
         v

   patch{p} =
      ;; TODO: investigate what happens when a patch introduces an
      ;; item with, say, ID == x, which needs to be patched, but the
      ;; patch for ID == x was applied before. This should be ok if
      ;; the item is already in the directory, otherwise it may fail.
      @version += 1
      p.list{} each {id, obj-patch} ->
         @get-all{id} each obj ->
            patch-shallow{obj, p, @}

   [^methods.fork]{dir} =
      throw E.fork{"Cannot fork directories."}
   [^methods.proxy]{tracks, patch, prevent-dirty-reads} =
      throw E.proxy{"Cannot proxy directories."}
   [^methods.patch]{p, dir} =
      throw E.patch{"Cannot patch directories."}
   [^methods.clobber]{new, dir} =
      throw E.clobber{"Cannot clobber directories."}
   [^methods.iterate-properties]{} =
      throw E.iterate{"Cannot iterate directories."}


;;;;;;;;;;;;;;;;;;;
;; PATCH HELPERS ;;
;;;;;;;;;;;;;;;;;;;

patch-shallow{deprox! match value, p, dir} =
   null? or undefined? -> ;; or Number? or String? or Symbol? or Boolean? ->
      pass
   else ->
      deprox{value}[methods.patch]{p, dir}

