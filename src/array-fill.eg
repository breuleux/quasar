
;; require:
;;    .util ->
;;       identify, fork-identify, tuck
;;       next-id, ID
;;       methods
;;       longest-run
;;    .proxy ->
;;       deprox
;;    .clobber ->
;;       array-clobber-helper


;; ;;;;;;;;;;
;; ;; FORK ;;
;; ;;;;;;;;;;

;; method Array.prototype[methods.fork]{} =
;;    @slice{0}


;; ;;;;;;;;;;;
;; ;; PATCH ;;
;; ;;;;;;;;;;;

;; Array.prototype[methods.patch]{p, dir, wrapper = this} =
;;    arr = this
;;    identify{wrapper}
;;    splices = p.get-for{wrapper}??["@splice"]
;;    if not splices:
;;       return
;;    enumerate{splices}.reverse{} each {i, match} ->
;;       {n, repl} ->
;;          previous = arr.splice{i, n}
;;          var acq =
;;             zip{repl.slice{0, previous.length}, previous} each {newv, oldv} ->
;;                dir.replace{oldv, deprox{newv}}
;;          acq ++= repl.slice{previous.length} each newv ->
;;             dir.acquire{deprox{newv}}
;;          previous.slice{repl.length} each oldv ->
;;             dir.exit{oldv}
;;          arr.splice{i, 0, *acq}
;;       else ->
;;          pass
;;    undefined


;; ;;;;;;;;;;;;;
;; ;; CLOBBER ;;
;; ;;;;;;;;;;;;;

;; Array.prototype[methods.clobber]{new-arr, dir} =

;;    arr = this

;;    if not Array? new-arr:
;;       return dir.replace{arr, new-arr, false}

;;    dir.unlist{arr}

;;    exits = new Set{}
;;    keeps = new Set{}

;;    array-clobber-helper{arr, new-arr, dir.duplicate} each
;;       #clobber{i, value} ->
;;          arr[i] = dir.clobber{arr[i], value}
;;       #splice{var start, var n, inserts} ->
;;          start..[start + n] each i ->
;;             exits.add{arr[i]}
;;          arr.splice{start, n, *acquired} where
;;             acquired = inserts each
;;                #keep{x} ->
;;                   keeps.add{x}
;;                   x
;;                #acquire{x} -> dir.acquire{x}

;;    exits each x when not keeps.has{x} ->
;;       dir.exit{x}

;;    tuck{arr, ID, new-arr[ID]}
;;    dir.list{arr}
;;    arr


;; ;;;;;;;;;;;;;;;;;;;;;;;;
;; ;; ITERATE-PROPERTIES ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;

;; Array.prototype[methods.set]{i, value} =
;;    this[i] = value

;; Array.prototype[methods.iterate-properties]{wrapper = this} =
;;    arr = this
;;    id = wrapper[ID]
;;    enumerate{arr} each {i, v} ->
;;       {i, v, setter} where
;;          setter{new-v} =
;;             arr[methods.set]{i, new-v}


;; ;;;;;;;;;;;;;;;;;;;;;;;;
;; ;; CHANGED-RELEVANTLY ;;
;; ;;;;;;;;;;;;;;;;;;;;;;;;

;; gen Array.prototype[methods.relevant-changes]{reads, writes} =
;;    match writes["@splice"]:
;;       undefined? ->
;;          pass
;;       splices ->
;;          var mask = 3
;;          taints = splices each
;;             undefined? -> 3 &+ mask
;;             {1, {_}} -> 1 &+ mask
;;             else -> [mask = 0; 0]
;;          items{reads} each
;;             {"@iter", v} ->
;;                yield v
;;             {n, v} when v??.not-empty{} ->
;;                if taints[n] != 3:
;;                   yield v

