
require:
   .util ->
      identify, fork-identify, tuck
      next-id, ID, FORKID, VERSION, DIRECTORY, CACHE
      methods
      longest-run
   .proxy ->
      deprox
   ;; .iter ->
   ;;    iterate-properties

provide:
   array-clobber-helper


;;;;;;;;;;
;; FORK ;;
;;;;;;;;;;

method Array.prototype[methods.fork]{} =
   @slice{0}


;;;;;;;;;;;
;; PATCH ;;
;;;;;;;;;;;

Array.prototype[methods.patch]{p, dir, wrapper = this} =
   arr = this
   identify{wrapper}
   splices = p.get-for{wrapper}??["@splice"]
   if not splices:
      return
   enumerate{splices}.reverse{} each {i, match} ->
      {n, repl} ->
         previous = arr.splice{i, n}
         var acq =
            zip{repl.slice{0, previous.length}, previous} each {newv, oldv} ->
               dir.replace{oldv, deprox{newv}}
         acq ++= repl.slice{previous.length} each newv ->
            dir.acquire{deprox{newv}}
         previous.slice{repl.length} each oldv ->
            dir.exit{oldv}
         arr.splice{i, 0, *acq}
      else ->
         pass
   undefined


;;;;;;;;;;;;;
;; CLOBBER ;;
;;;;;;;;;;;;;

array-clobber-helper{arr, new-arr, duplicate = true} =

   ;; 1. For each element of the new array, find the index of the
   ;; corresponding element in the old array.

   ;; 2. Find the longest filtering of the array of indices such
   ;; that the indices are in order.

   ;; 3. Splice the data around these fixed points, which should
   ;; amount to the minimal splicing that transforms the array

   idpos = {=}
   enumerate{arr} each {i, match x} ->
      {^ID => Number? id} -> idpos[id] = {i, x}
      else -> continue

   indices = enumerate{new-arr} each {i, match x} ->
      {^ID => Number? id} when idpos[id] -> {i, idpos[id][0]}
      else -> continue

   run = longest-run{indices, cmp, {-1, -1}} where
      cmp{{_, p1}, {_, p2}} = p1 < p2

   newids = {=}
   new-arr each x and {^ID => Number? id} when true ->
      newids[id] = true
   disposable = {=}
   arr each x and {^ID => Number? id} when not newids[id] ->
      disposable[id] = true

   if duplicate:
      run each {new-i, old-i} ->
         ;; These will be automatically preserved
         if arr[old-i] and arr[old-i][ID]:
            delete idpos[arr[old-i][ID]]

   run.push with {new-arr.length, arr.length}

   var old-current = 0
   var new-current = 0

   operations = {}
   run each {new-i, old-i} ->
      var n = old-i - old-current
      fresh = new-arr.slice{new-current, new-i}

      ;; Clobber what we can, shifting the splice
      while n > 0 and old-current < old-i and fresh.length > 0:
         match arr[old-current]:
            null? or undefined? or String? or Number? or Boolean? or Function? ->
               operations.push with #clobber{new-current, fresh.shift{}}
               old-current += 1
               new-current += 1
               n -= 1
            {^ID => Number? id} when disposable[id] ->
               operations.push with #clobber{new-current, fresh.shift{}}
               old-current += 1
               new-current += 1
               n -= 1
            else ->
               break

      ;; But now we have to replace a slice
      inserts = fresh each
         entry and {_, orig} is idpos[entry[ID] or -1] when entry and duplicate ->
            ;; We can recover this entry; however dir.duplicate prevents
            ;; us from having the same reference more than once in the
            ;; tree, so we remove it from idpos so we can't reuse it.
            delete idpos[entry[ID]]
            #keep{orig}
         entry ->
            #acquire{entry}

      operations.push with
         #splice{new-current, n, inserts}
      old-current = old-i + 1
      new-current = new-i + 1

   operations


Array.prototype[methods.clobber]{new-arr, dir} =

   arr = this

   if not Array? new-arr:
      return dir.replace{arr, new-arr, false}

   dir.unlist{arr}

   exits = new Set{}
   keeps = new Set{}

   array-clobber-helper{arr, new-arr, dir.duplicate} each
      #clobber{i, value} ->
         arr[i] = dir.clobber{arr[i], value}
      #splice{var start, var n, inserts} ->
         start..[start + n] each i ->
            exits.add{arr[i]}
         arr.splice{start, n, *acquired} where
            acquired = inserts each
               #keep{x} ->
                  keeps.add{x}
                  x
               #acquire{x} -> dir.acquire{x}

   exits each x when not keeps.has{x} ->
      dir.exit{x}

   tuck{arr, ID, new-arr[ID]}
   dir.list{arr}
   arr


;;;;;;;;;;;;;;;;;;;;;;;;
;; ITERATE-PROPERTIES ;;
;;;;;;;;;;;;;;;;;;;;;;;;

Array.prototype[methods.set]{i, value} =
   this[i] = value

Array.prototype[methods.iterate-properties]{wrapper = this} =
   arr = this
   id = wrapper[ID]
   enumerate{arr} each {i, v} ->
      {i, v, setter} where
         setter{new-v} =
            arr[methods.set]{i, new-v}


;;;;;;;;;;;;;;;;;;;;;;;;
;; CHANGED-RELEVANTLY ;;
;;;;;;;;;;;;;;;;;;;;;;;;

gen Array.prototype[methods.relevant-changes]{reads, writes} =
   match writes["@splice"]:
      undefined? ->
         pass
      splices ->
         var mask = 3
         taints = splices each
            undefined? -> 3 &+ mask
            {1, {_}} -> 1 &+ mask
            else -> [mask = 0; 0]
         items{reads} each
            {"@iter", v} ->
               yield v
            {n, v} when v??.not-empty{} ->
               if taints[n] != 3:
                  yield v

